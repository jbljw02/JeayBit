{"ast":null,"code":"import { getBatch } from './batch'; // encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\nfunction createListenerCollection() {\n  var batch = getBatch();\n  var first = null;\n  var last = null;\n  return {\n    clear: function clear() {\n      first = null;\n      last = null;\n    },\n    notify: function notify() {\n      batch(function () {\n        var listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get: function get() {\n      var listeners = [];\n      var listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe: function subscribe(callback) {\n      var isSubscribed = true;\n      var listener = last = {\n        callback: callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nvar nullListeners = {\n  notify: function notify() {},\n  get: function get() {\n    return [];\n  }\n};\nexport function createSubscription(store, parentSub) {\n  var unsubscribe;\n  var listeners = nullListeners; // Reasons to keep the subscription active\n\n  var subscriptionsAmount = 0; // Is this specific subscription subscribed (or only nested ones?)\n\n  var selfSubscribed = false;\n  function addNestedSub(listener) {\n    trySubscribe();\n    var cleanupListener = listeners.subscribe(listener); // cleanup nested sub\n\n    var removed = false;\n    return function () {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n  function trySubscribe() {\n    subscriptionsAmount++;\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = undefined;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n  var subscription = {\n    addNestedSub: addNestedSub,\n    notifyNestedSubs: notifyNestedSubs,\n    handleChangeWrapper: handleChangeWrapper,\n    isSubscribed: isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: function getListeners() {\n      return listeners;\n    }\n  };\n  return subscription;\n}","map":{"version":3,"names":["getBatch","createListenerCollection","batch","first","last","clear","notify","listener","callback","next","get","listeners","push","subscribe","isSubscribed","prev","unsubscribe","nullListeners","createSubscription","store","parentSub","subscriptionsAmount","selfSubscribed","addNestedSub","trySubscribe","cleanupListener","removed","tryUnsubscribe","notifyNestedSubs","handleChangeWrapper","subscription","onStateChange","undefined","trySubscribeSelf","tryUnsubscribeSelf","getListeners"],"sources":["C:/VS_Project/JeayBit/client/node_modules/react-redux/es/utils/Subscription.js"],"sourcesContent":["import { getBatch } from './batch'; // encapsulates the subscription logic for connecting a component to the redux store, as\r\n// well as nesting subscriptions of descendant components, so that we can ensure the\r\n// ancestor components re-render before descendants\r\n\r\nfunction createListenerCollection() {\r\n  const batch = getBatch();\r\n  let first = null;\r\n  let last = null;\r\n  return {\r\n    clear() {\r\n      first = null;\r\n      last = null;\r\n    },\r\n\r\n    notify() {\r\n      batch(() => {\r\n        let listener = first;\r\n\r\n        while (listener) {\r\n          listener.callback();\r\n          listener = listener.next;\r\n        }\r\n      });\r\n    },\r\n\r\n    get() {\r\n      let listeners = [];\r\n      let listener = first;\r\n\r\n      while (listener) {\r\n        listeners.push(listener);\r\n        listener = listener.next;\r\n      }\r\n\r\n      return listeners;\r\n    },\r\n\r\n    subscribe(callback) {\r\n      let isSubscribed = true;\r\n      let listener = last = {\r\n        callback,\r\n        next: null,\r\n        prev: last\r\n      };\r\n\r\n      if (listener.prev) {\r\n        listener.prev.next = listener;\r\n      } else {\r\n        first = listener;\r\n      }\r\n\r\n      return function unsubscribe() {\r\n        if (!isSubscribed || first === null) return;\r\n        isSubscribed = false;\r\n\r\n        if (listener.next) {\r\n          listener.next.prev = listener.prev;\r\n        } else {\r\n          last = listener.prev;\r\n        }\r\n\r\n        if (listener.prev) {\r\n          listener.prev.next = listener.next;\r\n        } else {\r\n          first = listener.next;\r\n        }\r\n      };\r\n    }\r\n\r\n  };\r\n}\r\n\r\nconst nullListeners = {\r\n  notify() {},\r\n\r\n  get: () => []\r\n};\r\nexport function createSubscription(store, parentSub) {\r\n  let unsubscribe;\r\n  let listeners = nullListeners; // Reasons to keep the subscription active\r\n\r\n  let subscriptionsAmount = 0; // Is this specific subscription subscribed (or only nested ones?)\r\n\r\n  let selfSubscribed = false;\r\n\r\n  function addNestedSub(listener) {\r\n    trySubscribe();\r\n    const cleanupListener = listeners.subscribe(listener); // cleanup nested sub\r\n\r\n    let removed = false;\r\n    return () => {\r\n      if (!removed) {\r\n        removed = true;\r\n        cleanupListener();\r\n        tryUnsubscribe();\r\n      }\r\n    };\r\n  }\r\n\r\n  function notifyNestedSubs() {\r\n    listeners.notify();\r\n  }\r\n\r\n  function handleChangeWrapper() {\r\n    if (subscription.onStateChange) {\r\n      subscription.onStateChange();\r\n    }\r\n  }\r\n\r\n  function isSubscribed() {\r\n    return selfSubscribed;\r\n  }\r\n\r\n  function trySubscribe() {\r\n    subscriptionsAmount++;\r\n\r\n    if (!unsubscribe) {\r\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\r\n      listeners = createListenerCollection();\r\n    }\r\n  }\r\n\r\n  function tryUnsubscribe() {\r\n    subscriptionsAmount--;\r\n\r\n    if (unsubscribe && subscriptionsAmount === 0) {\r\n      unsubscribe();\r\n      unsubscribe = undefined;\r\n      listeners.clear();\r\n      listeners = nullListeners;\r\n    }\r\n  }\r\n\r\n  function trySubscribeSelf() {\r\n    if (!selfSubscribed) {\r\n      selfSubscribed = true;\r\n      trySubscribe();\r\n    }\r\n  }\r\n\r\n  function tryUnsubscribeSelf() {\r\n    if (selfSubscribed) {\r\n      selfSubscribed = false;\r\n      tryUnsubscribe();\r\n    }\r\n  }\r\n\r\n  const subscription = {\r\n    addNestedSub,\r\n    notifyNestedSubs,\r\n    handleChangeWrapper,\r\n    isSubscribed,\r\n    trySubscribe: trySubscribeSelf,\r\n    tryUnsubscribe: tryUnsubscribeSelf,\r\n    getListeners: () => listeners\r\n  };\r\n  return subscription;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}